"use strict";(self.webpackChunkslop_site=self.webpackChunkslop_site||[]).push([[1623],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(a),m=r,d=p["".concat(l,".").concat(m)]||p[m]||h[m]||o;return a?n.createElement(d,s(s({ref:t},u),{},{components:a})):n.createElement(d,s({ref:t},u))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4761:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={sidebar_position:5},s="Switch",i={unversionedId:"Language/Statements/switch",id:"Language/Statements/switch",title:"Switch",description:"The switch statement has been so far the most ambitious of the project. Being frustrated by the lack of flexibility in",source:"@site/docs/Language/Statements/switch.md",sourceDirName:"Language/Statements",slug:"/Language/Statements/switch",permalink:"/docs/Language/Statements/switch",draft:!1,editUrl:"https://gitlab.com/tronied/slop/docs/Language/Statements/switch.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"For Each (Loop)",permalink:"/docs/Language/Statements/for-each"},next:{title:"Field",permalink:"/docs/Language/Statements/field"}},l={},c=[{value:"Multiple Parameters",id:"multiple-parameters",level:2},{value:"Future Improvements",id:"future-improvements",level:2}],u={toc:c};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"switch"},"Switch"),(0,r.kt)("p",null,"The switch statement has been so far the most ambitious of the project. Being frustrated by the lack of flexibility in\nthe Java version, I attempted to overcome these shortfalls by adding many of the features I would have liked to be\npresent as possible. Whether all of these changes somehow removes the basic idea of a simple switch is up for debate,\nbut below I will list and explain these features below."),(0,r.kt)("p",null,"At it's core the idea of a switch is simple. You evaluate a single value against a set of other values (or cases) and\nexecute code paired with the match. At the basic level the SLOP statement does not differ from that, you can still\nuse that formula:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(emp.name)["Mary": "Banker";"Bob": "Coder"; "Jim": "Marketing"; default: "I don\'t know"]\n')),(0,r.kt)("p",null,"In this case our value is passed as a parameter and cases are separated by semi-colons with the condition present before\nthe colon and the result after. So far so simple, but one of the restrictive things about this model is the limited\ncases (no pun intended) where you can use this. What happens if you want to evaluate integers for example? Say we have\nmultiple conditions where we want to check whether a value falls within some set boundaries. In Java this is not currently\npossible at the time of writing this. In SLOP though we have no such restriction and therefore can use the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(person.age)[< 1: "Baby";< 3: "Toddler";< 12: "Adolescent"; ...]\n')),(0,r.kt)("p",null,"Firstly there is an issue with the above statement. If you run it and the person declared in the parameter is 2 for example,\nthe result would be a collection of multiple results being ",'["Toddler", "Adolescent", ...]'," and every case after. This is\nbecause the switch statement does not stop when it finds a match by default and will return all matching condition results\nin the set. The avoid this we can use the '!' flag following the case definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(person.age)[< 1: "Baby"!;< 3: "Toddler"!;< 12: "Adolescent"!; ...]\n')),(0,r.kt)("p",null,'The above would now return the correct result of just "Toddler". You may notice that we are defining all case evaluations\nwithout specifying the value we\'re comparing it to. This is typical for a switch, but should this be required (especially\nwhen declaring multiple parameters - more on this later!), you can reference each parameter by doing the following:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(person.age)[$0 < 1: "Baby";$0 < 3: "Toddler";$0 < 12: "Adolescent"; ...]\n')),(0,r.kt)("p",null,"This is unnnecessary or the most part so you can ditch that just in favour of using the desired operator and comparison\nvalue. It is also not restricted to using single value evaluations. For example, we could do the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(person.salary)[> acme.revenue / acme.averageSalary: "High Earner"; ...]\n')),(0,r.kt)("p",null,"Much like the C / C++ / Java equivalents, the SLOP switch has a default case which acts as a fallback if none of the\nother cases match. The condition is replaced by the keyword 'default', but follows the same pattern with the result\nbeing provided after the semi-colon. An example of this can be seen in the first example on this page."),(0,r.kt)("h2",{id:"multiple-parameters"},"Multiple Parameters"),(0,r.kt)("p",null,"A typical switch has one parameter by which it is used to compare against the cases. What would happen though if we\nwanted to pass in multiple values or use those in a condition? You can provide multiple parameters by defining them\nseparated by a comma. There are two methods of evaluating these parameters in each switch case. The first is using\nthem in a single condition. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(acme.outgoings, acme.revenue)[$0 > $1: "Deficit";$0 < $1: "Profit";$0 == $1: "Holding Even"]\n')),(0,r.kt)("p",null,"Here we are using the earlier method of referencing parmeters. It could be argued that the values could be simply referenced\nwithout passing them as parameters which is true, however by using the parameter reference it makes it a lot more concise.\nUsing this same method you can also evaluate both parameters against some value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(acme.outgoings, acme.revenue)[\n    $0 > 500000 AND $1 - $0 > 100000: "We\'re Ok";\n    $0 > 750000 AND $1 - $0 > 50000: "Cause for concern"; \n    $0 > 750000 AND $1 - $0 <= 10000: "Uh oh"; \n    ...\n]\n')),(0,r.kt)("p",null,"As one final feature of the SLOP switch, parameters can be contained within their own conditions separated by a comma\ncharacter. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(a.intA, a.intB, a.intC)[>5,>10,>15: "First";>10,<12,20: "Second"]\n')),(0,r.kt)("p",null,"When defining parameter conditions like this, you must ensure that the number of comma separated conditions matches\nthe number of parameters otherwise an exception will be thrown."),(0,r.kt)("h2",{id:"future-improvements"},"Future Improvements"),(0,r.kt)("p",null,"These are the features I will also be looking to add in the near future:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Evaluation against arrays of objects. This would be similar to how a contains() works against the parameter variable.\nFor example, you could use:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(emp.name)[["Mary","Bob","Susan"]: "Board Member"; default: "Employee"]\n'))),(0,r.kt)("li",{parentName:"ol"},"Similar to the multiple expressions suppported by the repeat and for-each, add the ability to add groups of expressions\nper case. As the current case syntax separator is already a semi-colon, an optional grouping could be added e.g.:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},'switch(emp.age)[<30: {empAgeCompanyAge = $0 * acme.age; result = "R = " + empAgeCompanyAge}]\n')))))}p.isMDXComponent=!0}}]);