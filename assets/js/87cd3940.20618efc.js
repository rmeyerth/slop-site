"use strict";(self.webpackChunkslop_site=self.webpackChunkslop_site||[]).push([[3307],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),h=o,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||a;return t?r.createElement(m,i(i({ref:n},u),{},{components:t})):r.createElement(m,i({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=t(7462),o=(t(7294),t(3905));const a={sidebar_position:2},i="Grammar",s={unversionedId:"Extending/grammar",id:"Extending/grammar",title:"Grammar",description:"The grammar pattern determines not only the structure of the statement and how it can be defined, but also structure",source:"@site/docs/Extending/grammar.md",sourceDirName:"Extending",slug:"/Extending/grammar",permalink:"/docs/Extending/grammar",draft:!1,editUrl:"https://gitlab.com/tronied/slop/docs/Extending/grammar.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Design Approach",permalink:"/docs/Extending/design-approach"},next:{title:"Adding Types / Operations",permalink:"/docs/Extending/type-operations"}},l={},p=[],u={toc:p};function c(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"grammar"},"Grammar"),(0,o.kt)("p",null,"The grammar pattern determines not only the structure of the statement and how it can be defined, but also structure\nof how the tokens are organised into groups for processing. To start there are two basic grammar tokens which cause\nother values to be captured. These are 'val' (single) and 'expr' (multiple). Around this you can group tokens together\nusing brackets or define syntax by wrapping values in single quotes. For example, the grammar for a FunctionToken is\nthe following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"val '(' ( expr ','? )+ ')'\n")),(0,o.kt)("p",null,"Breaking this down we get the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"val   = Captures single value\n'('   = Denotes an opening bracket in the syntax\n(     = Start of a grammar group\nexpr  = Captures one or more values\n','?  = An optional comma value. '?' marks the preceding token as optional\n)+    = End of the grammar group. The '+' denotes that the contents of this group can be repeated one or more times\n')'   = A closing bracket in the syntax\n")),(0,o.kt)("p",null,"Using this we can pass the following values in an expression which would be a valid match:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'DATE("14-02-1983 15:49:03", "dd-MM-yyyy hh:mm:ss")\nSUM(45 * 15 + 1, 2 / 3, 3)\n')),(0,o.kt)("p",null,"The first match would result in the following token output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'FunctionToken( tokenGroups = [\n    TokenGroup( tokens = [\n        StringToken( value = "DATE" )\n    ],\n    TokenGroup( tokens = [\n        TokenGroup ( tokens = [ StringToken( value = "14-02-1983 15:49:03" ) ] ),\n        TokenGroup ( tokens = [ StringToken( value = "dd-MM-yyyy hh:mm:ss" ) ] ),\n    ] )\n] )\n')),(0,o.kt)("p",null,"In the above example, the 'val' capture group even though it is a single token gets added into its own TokenGroup. A\nsecond TokenGroup gets added to contain the one or more 'expr' capture groups that are expected. Expressions\nrepresentative of one or more tokens always get added into their own TokenGroups so that there is a clear split between\nsubsequent parameters (in this case) and the tokens which go to constructing that single parameter."),(0,o.kt)("p",null,"For the more complicated second example, it would be the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'FunctionToken( tokenGroups = [\n    TokenGroup( tokens = [\n        StringToken( value = "SUM" )\n    ],\n    TokenGroup( tokens = [\n        TokenGroup ( tokens = [\n            IntegerToken( value = 45 ),\n            OperatorToken( value = * ),\n            IntegerToken( value = 15 ),\n            OperatorToken( value = + ),\n            IntegerToken( value = 1 )\n        ] ),\n        TokenGroup ( tokens = [\n            IntegerToken( value = 2 ),\n            OperatorToken( value = / ),\n            IntegerToken( value = 3 ),\n        ] ),\n        TokenGroup ( tokens = [ IntegerToken( value = 3 ) ] )\n    ] )\n] )\n')),(0,o.kt)("p",null,"When defining a grammar pattern you should be aware of the structure of other tokens defined within SLOP. Should\none of the existing Tokens conflict with the new Token and the Lexer is unsure of which match to use, it will\nthrow a LexerException to highlight the issue."),(0,o.kt)("p",null,"There is one final token which can be used when specifying grammar which is the '<' flag. This can be seen in\nthe SwitchToken:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"}," ... ( expr ','? )+ ':' expr '!'<? ';'? )+ ...\n")),(0,o.kt)("p",null,"This can follow a syntax token and tells the Lexer not to discard it but instead add it to the context as it would\nwith a normal token as a TokenValue or NonToken. This can be useful to pass flags to the token processing code\n(triggered by the Parser) to denote a certain situation. In the above example if an exclamation mark is found in a\nswitch case then it will stop looking at any other cases (similar to how a break works in the Java switch statement)."),(0,o.kt)("p",null,"If constructing a new Grammar expression string is still confusing and how it relates to the resulting TokenGroup\nstructure, please follow the example provided in the ",(0,o.kt)("a",{parentName:"p",href:"#adding-statements"},"Adding Statements")," section."))}c.isMDXComponent=!0}}]);