"use strict";(self.webpackChunkslop_site=self.webpackChunkslop_site||[]).push([[2711],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,f=p["".concat(l,".").concat(h)]||p[h]||d[h]||s;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:a,i[1]=o;for(var c=2;c<s;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},658:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const s={sidebar_position:2},i="Chained Expressions",o={unversionedId:"Language/Extra Features/chained-expressions",id:"Language/Extra Features/chained-expressions",title:"Chained Expressions",description:"These are where the result of one expression can be referenced in another, effectively creating a chain to",source:"@site/docs/Language/Extra Features/chained-expressions.md",sourceDirName:"Language/Extra Features",slug:"/Language/Extra Features/chained-expressions",permalink:"/slop-site/docs/Language/Extra Features/chained-expressions",draft:!1,editUrl:"https://gitlab.com/tronied/slop/docs/Language/Extra Features/chained-expressions.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Saving / Loading Lexer Output",permalink:"/slop-site/docs/Language/Extra Features/save-load-lexer-output"},next:{title:"Design Approach",permalink:"/slop-site/docs/Extending/design-approach"}},l={},c=[],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"chained-expressions"},"Chained Expressions"),(0,a.kt)("p",null,"These are where the result of one expression can be referenced in another, effectively creating a chain to\nreach the final result. Chained expressions are passed in a collection to the SLOPProcessor where special\nsyntax can be used to reference the previous result. The following test shows how this can be used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'    @Test\n    public void testSimpleChainedResults() {\n        assertEquals(2, processor.process(Arrays.asList(\n                "4 * 4",\n                "{?} / 4",\n                "{?} - 2"\n        )).getValue());\n    }\n')),(0,a.kt)("p",null,"Each expression passed results in value that can be referenced using the ",(0,a.kt)("inlineCode",{parentName:"p"},"{?}")," reference. In the case above\nthe first simply calculates 4 multiplied by itself resulting in 16. This is then referenced in the next expression\nand divided by itself to become 4. The final expression then subtracts to reach the final result which is 2. These\nreferences are a special feature which can be used for expression chains but are not required. Take the following\nfor example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'    @Test\n    public void testAssignNameChainedExpression() {\n        assertEquals(12, processor.process(Arrays.asList(\n                "resultA = 4 * 4",\n                "resultB = resultA / 4",\n                "resultB - 2"\n        )).getValue());\n    }\n')),(0,a.kt)("p",null,"In this case we are using variables to achieve the same result. Each expression in the chain is executed\nsequentially, but the final result will be that of only the final expressions result. Chained expressions are\nuseful when the there are multiple calculations required to reach a goal but performing it in a single expression\nwould make it complicated and difficult to read. This way it can be broken down into component parts and results."))}p.isMDXComponent=!0}}]);