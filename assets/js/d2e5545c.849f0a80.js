"use strict";(self.webpackChunkslop_site=self.webpackChunkslop_site||[]).push([[4369],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||o;return n?a.createElement(d,s(s({ref:t},c),{},{components:n})):a.createElement(d,s({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6133:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:1},s="Overview",i={unversionedId:"Language/overview",id:"Language/overview",title:"Overview",description:"SLOP includes five main components:",source:"@site/docs/Language/overview.md",sourceDirName:"Language",slug:"/Language/overview",permalink:"/slop-site/docs/Language/overview",draft:!1,editUrl:"https://gitlab.com/tronied/slop/docs/Language/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/slop-site/docs/intro"},next:{title:"Literals",permalink:"/slop-site/docs/Language/literals"}},l={},p=[{value:"Processor",id:"processor",level:2},{value:"Configuration Class",id:"configuration-class",level:2},{value:"Lexer",id:"lexer",level:2},{value:"Parser",id:"parser",level:2},{value:"Context",id:"context",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overview"},"Overview"),(0,r.kt)("p",null,"SLOP includes five main components:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#processor"},"Processor"),": ",(0,r.kt)("em",{parentName:"li"},"Evaluates expressions, ability to save / import lexer output and override other SLOP components.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#config-class"},"Config Class"),": ",(0,r.kt)("em",{parentName:"li"},"Declaration of token classes (literals, operators, statements etc) and management of properties.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#lexer"},"Lexer"),": ",(0,r.kt)("em",{parentName:"li"},"Converts the String expression into a hierarchical set of tokens that can be read by the parser.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#parser"},"Parser"),": ",(0,r.kt)("em",{parentName:"li"},"Reads tokens and defers responsibility to each handler and type operation classes to resolve values")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#context"},"Context"),": ",(0,r.kt)("em",{parentName:"li"},"Contains objects that are referenced in the expression. Used to store variables."))),(0,r.kt)("h2",{id:"processor"},"Processor"),(0,r.kt)("p",null,"The processor class is the starting point for anyone wishing to use or configure SLOP. It can evaluate static expressions by\nusing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"SLOPProcessor.processStatic(\"3 > 4 ? 'no' : 'yes'\").getValue(String.class);\n")),(0,r.kt)("p",null,"or by creating an instance and calling the process method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"SLOPProcessor processor = new SLOPProcessor();\nprocessor.process(\"3 > 4 ? 'no' : 'yes'\").getValue(String.class);\n")),(0,r.kt)("p",null,"Each accepts a context object and each has its own advantages over the other. The static version is quick to call\nwithout the need to create an instance. It is meant for fast lightweight evaluation of expressions, though this\ndoes impact performance making multiple requests. Also, unlike the instanced version it does not provide the ability to\nserialize the lexer output, chain expressions (See ",(0,r.kt)("a",{parentName:"p",href:"#extra-features"},"Extra Features"),"), or modify the configuration /\noverride other SLOP components."),(0,r.kt)("h2",{id:"configuration-class"},"Configuration Class"),(0,r.kt)("p",null,"The configuration class can be ignored by most users but is useful to those wishing to add / modify existing functionality.\nIt provides methods to add literals, type operations, statements and customize operators. For example, by creating\na default configuration class, setting the setOperatorHandler method to the following, you can change the default operators\nto use a different set:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'SLOPConfig config = new SLOPConfig();\nconfig.setOperatorHandler(new VerboseOperator(""));\nSLOPProcessor processor = SLOPProcessor(config);\n')),(0,r.kt)("p",null,"Now when defining an expression, instead of declaring:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"1 + 3 / (5 * 9) % 2\n")),(0,r.kt)("p",null,"You can use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"1 add 3 div (5 mul 9) mod 2\n")),(0,r.kt)("p",null,"Why would you do this? I have no idea, but it shows that every aspect of SLOP can be changed if you so wish. If you're\ncurious, please take a look at the default OperatorToken class compared with the VerboseOperator class to see how this can\nbe done."),(0,r.kt)("p",null,"Another important aspect of the configuration class is defining and setting custom properties. The tokens use these\nproperties to alter their behaviour or end result. At this stage (and to avoid confusion), everything that is\nread from an expression String is mapped to a token class (literals, statements etc). Although I will go into this\nlater in greater detail (See ",(0,r.kt)("a",{parentName:"p",href:"#extending"},"Extending"),"), each token class contains the pattern and code to process a\nresult. As such, when I refer to tokens I am referring to them in their abstract form using this context."),(0,r.kt)("p",null,"There are some general properties which have been defined in a DefaultProperties class. These are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},' DATE_FORMAT("dateFormat"),\n ESCAPE_CHARACTER("escapeCharacter"),\n OR_OPERATOR("orOperator"),\n DEBUG_MODE("debugMode"),\n SAFE_OPERATIONS("safeOperations");\n')),(0,r.kt)("p",null,"As a quick run through of each:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The date format determines the default format used when using the DATE function e.g. dd-MM-yyyy"),(0,r.kt)("li",{parentName:"ul"},'Determines which character can be used as an escape character e.g. "Test String \\"Inner String\\"". In this case\nit\'s using the backslash character.'),(0,r.kt)("li",{parentName:"ul"},"The keyword used as an OR operator. This is a legacy entry and would recommend looking to the LogicOperator class instead."),(0,r.kt)("li",{parentName:"ul"},"Debug mode enables all debug messages to see how values were derived."),(0,r.kt)("li",{parentName:"ul"},"Safe operations is enabled by default. Disabling allows native calls (via reflection) to be called on objects. For example:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"SLOPConfig config = new SLOPConfig();\nconfig.setProperty(DefaultProperties.SAFE_OPERATIONS, false)\nSLOPProcessor processor = new SLOPProcessor(config);\nprocessor.process(\"'testing'.substring(1,4).concat('run')\"); //Results in \"testrun\"\n")),"Using the above example, attempting a native call without setting that property will throw a ParserException.")),(0,r.kt)("p",null,"The above properties are the default set included with SLOP, however you can add your own and use them within your own\nstatements. Please see the ",(0,r.kt)("a",{parentName:"p",href:"#adding-statements"},"Adding Statements")," section for more information."),(0,r.kt)("h2",{id:"lexer"},"Lexer"),(0,r.kt)("p",null,"Lexers are used to transform different types of expressions into a series of tokens. SLOP uses two lexers which are the\nSLOPGrammarLexer and SLOPLexer. As per it's name, the first is dedicated to translating token grammar Strings into\npattern tokens. Pattern tokens are used by the second lexer to match the current token (read from an expression) to an\nequivalent token type as either a new match or existing item in the stack. Please see the ",(0,r.kt)("a",{parentName:"p",href:"#design"},"Design")," section for\nmore information on how the Lexer processes an Expression String."),(0,r.kt)("h2",{id:"parser"},"Parser"),(0,r.kt)("p",null,"The parser takes the tokens mapped by the lexer and resolves them into one or more resulting values. It does this by\ndeferring responsibility to each token for resolution of it's value. For example, given the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"(1 + 2) / 2\n")),(0,r.kt)("p",null,"This would equate to the following token structure from the Lexer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'TokenGroup[\n   OperationToken[\n      IntegerToken(1),\n      OperatorToken("+"),\n      IntegerToken(2)\n   ],\n   OperatorToken("/"),\n   IntegerToken(2)\n]\n')),(0,r.kt)("p",null,'The Parser will loop through each token calling the process method to resolve their values. With most literal\ntokens (Integer / Operator / String), when invoked it simply returns its own value e.g. String("hello")\nwould be "hello". With a token like the OperationToken (itself a statement) that has three child tokens, these will have to be\ncalculated into a result. It is the responsibility of each token to resolve its own child tokens. Don\'t think though\nthat the token is left to fend for itself and start performing adding or subtracting calculations as that responsibility\ncan be passed back to the Parser. The Parser is a parameter in the process call and has methods to resolve a\nlist of tokens into a result. If this is confusing then I can appreciate that! For more information please see the\n',(0,r.kt)("a",{parentName:"p",href:"#design"},"Design")," section for more information on how the Parser and Tokens work together to resolve values."),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("p",null,"The context instance can be used to pass objects so that they can be evaluated and be referenced in Expression Strings.\nFor example, given the following classes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Company {\n    private String name;\n    private BigDecimal revenue;\n    private List<Employee> employees;\n    \n    //...\n}\n\nclass Employee {\n    private String name;\n    private int age;\n    \n    //All args constructor\n}\n")),(0,r.kt)("p",null,"We could create a context object and set the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'SLOPContext context = new SLOPContext();\n\n//Employees\nEmployee employeeA = new Employee("Mary", 34);\nEmployee employeeB = new Employee("Bob", 54);\nEmployee employeeC = new Employee("Susan", 64);\nEmployee employeeD = new Employee("Jim", 23);\n\n//Company\nCompany acmeCompany = new Company();\nacmeCompany.setName("ACME Company Plc");\nacmeCompany.setRevenue(BigDecimal.valueOf(129000000));\nacmeCompany.setEmployees(Arrays.asList(employeeA, employeeB, employeeC, employeeD));\n\ncontext.set("acme", acmeCompany);\n')),(0,r.kt)("p",null,"Now using the above, we could write the following to calculate revenue divided by the number of employees:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'SLOPConfig config = new SLOPConfig();\nconfig.setProperty(DefaultProperties.SAFE_OPERATIONS, false);\nSLOPProcessor processor = new SLOPProcessor(config);\nSystem.out.println("Result: " + processor.process("(acme.revenue / acme.employees.size()).intValue()"\n            .getValue(Integer.class));\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE"),": Because the default result from this would be a BigDecimal (3.225E..), we use the native call intValue() on\nthe result to get a more understandable figure. As such, this results in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Result: 32250000\n")),(0,r.kt)("p",null,"Using another example with the employee collection, let's say we wanted to extract each name into a collection.\nIn most languages you would iterate through each object adding the relevant field. This would be similar to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"repeat(index++;0;<acme.employees.size()) result = acme.employees[index].name;\n")),(0,r.kt)("p",null,"or when using the for-each statement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"foreach(emp : acme.employees) result = emp.name;\n")),(0,r.kt)("p",null,"You can however get the same result by skipping looping entirely and just specifying the collection and target field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"acme.employees.name\n")),(0,r.kt)("p",null,"All three above examples would result in the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'["Mary", "Bob", "Susan", "Jim"]\n')),(0,r.kt)("p",null,"For more information on the repeat or field token, please see the ",(0,r.kt)("a",{parentName:"p",href:"#statements"},"Statements")," section for\nmore information."))}u.isMDXComponent=!0}}]);