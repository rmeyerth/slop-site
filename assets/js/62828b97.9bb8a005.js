"use strict";(self.webpackChunkslop_site=self.webpackChunkslop_site||[]).push([[2990],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(t),g=r,m=p["".concat(l,".").concat(g)]||p[g]||d[g]||o;return t?a.createElement(m,i(i({ref:n},c),{},{components:t})):a.createElement(m,i({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},1349:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=t(7462),r=(t(7294),t(3905));const o={sidebar_position:4},i="Functions",s={unversionedId:"Language/functions",id:"Language/functions",title:"Functions",description:"SLOP has been designed to provide as much functionality as possible, but it may be the case where the right results",source:"@site/docs/Language/functions.md",sourceDirName:"Language",slug:"/Language/functions",permalink:"/docs/Language/functions",draft:!1,editUrl:"https://gitlab.com/tronied/slop/docs/Language/functions.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Operators",permalink:"/docs/Language/operators"},next:{title:"Conditional",permalink:"/docs/Language/Statements/conditional"}},l={},u=[],c={toc:u};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"functions"},"Functions"),(0,r.kt)("p",null,"SLOP has been designed to provide as much functionality as possible, but it may be the case where the right results\ncannot come by using expressions alone. This is where custom functions come into play. Functions can be written in\nthe native language but referenced within expression Strings. Only a limited set of functions have been provided in\nthe core SLOP package, but writing your own is very easy. Let's take a look at creating a random function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class RandomOp implements Function {\n\n    @Override\n    public String getName() {\n        return "RAND";\n    }\n\n    @Override\n    public Token<?> execute(SLOPConfig config, List<Token<?>> values) {\n        Random random = new Random();\n        if (values.size() < 1 || values.size() > 2) {\n            throw new ParserException("Expected two arguments e.g. \'RAND(\'integer\', 1000)\'");\n        }\n        if (!(values.get(0).getValue() instanceof String)) {\n            throw new ParserException("Expected random type (param 0) to be a String value. Valid values are: " +\n                    "\'integer\', \'double\', \'float\', \'long\', \'boolean\'");\n        }\n        String type = values.get(0).getValue(String.class);\n        if (values.size() == 2) {\n            if (!type.equalsIgnoreCase("integer")) {\n                throw new ParserException("Bound only supported when using the integer type");\n            }\n            if (values.get(1).getValue() instanceof Integer) {\n                throw new ParserException("The bound parameter must be specified as an integer");\n            }\n        }\n        switch (type) {\n            case "integer": return new TokenValue(values.size() == 1 ? random.nextInt() :\n                random.nextInt(values.get(1).getValue(Integer.class)));\n            case "float": return new TokenValue(random.nextFloat());\n            case "double": return new TokenValue(random.nextDouble());\n            case "boolean": return new TokenValue(random.nextBoolean());\n            case "long": return new TokenValue(random.nextLong());\n        }\n        throw new ParserException(String.format("Unexpected type provided in random function \'%s\'", type));\n    }\n}\n')),(0,r.kt)("p",null,"Functions are simple from a code standpoint as it requires only to implement the Function interface and methods.\nThe above will provide the ability to create random numbers using a type parameter to be used in an expression.\nIt is important when creating functions to check and throw errors if the parameter list is not in the expected\nformat. The code itself is fairly self-explanatory and will allow it to be called by using the RAND name and two\nparameters (the second being restricted on the type). Next we need to add it to our config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"SLOPConfig config = new SLOPConfig();\nconfig.addFunction(new RandomOp());\nSLOPProcessor processor = new SLOPProcessor(config);\n")),(0,r.kt)("p",null,"Finally we are ready to test it out. It can be useful to test any SLOP changes by using the SLOPRunner class in the\ntest package. This allows expressions to typed in and evaluated after the enter key is pressed. Here is some output\nfor our new function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'> RAND("integer")\nResult: 13788106 (Time taken: 3ms)\n> RAND("integer",1000)\nResult: 730 (Time taken: 5ms)\n> RAND("integer",100)\nResult: 55 (Time taken: 2ms)\n> RAND("boolean")\nResult: true (Time taken: 2ms)\n> RAND("boolean")\nResult: false (Time taken: 2ms)\n> RAND("float")\nResult: 0.5708346 (Time taken: 2ms)\n> RAND("long")\nResult: -7999691372481956837 (Time taken: 1ms)\n')),(0,r.kt)("p",null,"Functions can then be used in conjunction with other values to trigger an action or resolve a value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'> 3.1459 * RAND("float")\nResult: 0.20246804\n')),(0,r.kt)("p",null,"Although this is just an example, it shows that we can leverage the underlying native language to fulfill either\nshortfalls in what is possible with the included literals and statements or to avoid overly complex expressions.\nImagine a banking application where we have customers stored on a database. We could setup a custom notification\nstored on a record that is associated with a specific customer which is triggered each day or whenever a change\nis made to their account. The following will notify them if their main account falls below \xa3250 and it's still\nless than or equal to the 15th of each month:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'customer.mainAccount.total < 250.00 and DAY("LTE", 15) ? EMAIL_WARNING(customer) : null\n')))}p.isMDXComponent=!0}}]);